/*
 * Copyright (c) 2025 Talent Catalog.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see https://www.gnu.org/licenses/.
 */

package org.tctalent.server.repository.db.read.sql;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;
import org.tctalent.server.repository.db.read.dto.CandidateReadDto;

/**
 * DAO responsible for computing candidate JSON projections in PostgreSQL.
 *
 * IMPORTANT:
 * - This DAO does NOT cache.
 * - It always computes JSON from source tables using SQL generated by
 *   {@link SqlJsonQueryBuilder}.
 * - It returns raw JSON strings so they can be cached verbatim by callers.
 *
 * Transaction semantics:
 * - Read-only
 * - Joins an existing transaction if present
 * - Does not define transaction boundaries
 */
@Repository
@Transactional(readOnly = true)
@RequiredArgsConstructor
@Slf4j
public class CandidateJsonDao {

    private final NamedParameterJdbcTemplate jdbc;
    private final SqlJsonQueryBuilder sqlBuilder;

    /**
     * Compute candidate JSON for the given candidate IDs.
     *
     * @param ids candidate IDs to compute JSON for
     * @return map of candidateId -> JSON string
     *
     * STRICT:
     * - If Postgres returns no JSON for a candidate ID, that candidate will
     *   simply be missing from the returned map.
     * - Callers that require strict completeness must enforce it themselves
     *   (CandidateReadService does this).
     */
    public Map<Long, String> loadJsonByIds(Collection<Long> ids) {

        if (ids == null || ids.isEmpty()) {
            return Map.of();
        }

        String sql = sqlBuilder.buildByIdsQuery(
            CandidateReadDto.class,
            "ids"
        );

        return jdbc.query(
            sql,
            Map.of("ids", ids),
            rs -> {
                Map<Long, String> result = new HashMap<>();
                while (rs.next()) {
                    result.put(
                        rs.getLong("id"),
                        rs.getString("json") // alias from SqlJsonQueryBuilder
                    );
                }
                return result;
            }
        );
    }
}

